\documentclass[11pt]{article}
\usepackage[cache=false]{minted}
\usepackage{amsmath} %used for maths and "aligned" in equation
\usepackage{hyperref}


\usepackage{tcolorbox}
\usepackage{etoolbox}
\BeforeBeginEnvironment{minted}%
     {\begin{tcolorbox}}%
\AfterEndEnvironment{minted}
   {\end{tcolorbox}}%


\title{Algorithms}

\begin{document}
\maketitle

\section{Linked List}
We can use array to initialize the linked list as the following code.
While building up the linked list from the given array, we use the \textbf{two-pointer technique} to maintain the linking between two nodes.
\inputminted[breaklines=true,frame=leftline, linenos=true]{python}{src/linkedlist.py}

\section{Sliding Widow Technique}
\subsection{Count distinct elements in every window of size k}
Tag: Sliding Window Technique, Hashtable. 
See \footnote{https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/}.

\begin{minted}[xleftmargin=20pt]{bash}
Input:  arr[] = {1, 2, 1, 3, 4, 2, 3}, k = 4
Output: [3, 4, 4, 3]
\end{minted}

We use the sliding window to update a hashtable, which maintains the distinct elements. And the time complexity is $O(n)$.

\inputminted{python}{src/distinct.py}

\subsection{Sliding Window Maximum (Maximum of all subarrays of size k)}

See \footnote{https://www.geeksforgeeks.org/sliding-window-maximum-maximum-of-all-subarrays-of-size-k/}.
\begin{minted}[xleftmargin=20pt]{bash}
Input :
arr[] = {1, 2, 3, 1, 4, 5, 2, 3, 6}
k = 3
Output :
3 3 4 5 5 5 6

Input :
arr[] = {8, 5, 10, 7, 9, 4, 15, 12, 90, 13}
k = 4
Output :
10 10 10 15 15 90 90
\end{minted}

We use the priority queue to .

\inputminted{python}{src/maxSlidingWindow.py}

\section{Heap}
Heap can be viewed as a complete tree, but stored as the array. 
Suppose the current node's index is $idx$, then the left child's index is $2*idx+1$, and the right child $2*idx+2$, while the parent $floor((idx-1)/2)$.

We take the binary max heap as an example. 
The basic external function is \textbf{insert} and \textbf{extractMax}, which is implemented by \textbf{siftup} and \textbf{siftdown}. 
The \textbf{siftup} function check the current node's value with its parent's value, then swap them if the current node's value is bigger than the parent's, and do the check-swap operation recursively to meet the guarantee 
	of the binary max heap.
	
The python source code is as following.
\inputminted[breaklines=true,frame=leftline, linenos=true]{python}{src/heap.py}

\subsection{Python's heapq}
We can use the library \textbf{heapq} in python. 
Since the default \textbf{heapq} is the min heap, so we need a trick to reimplement \textbf{MaxHeap} by overriding the comparison function. 
\inputminted[breaklines=true,frame=leftline, linenos=true]{python}{src/heap_heapq.py}

Or we can implement \textbf{MaxHeap} by multiplying -1 to each item in an array directly when using \textbf{heapq}.

\inputminted[breaklines=true,frame=leftline, linenos=true]{python}{src/heap_heapq2.py}

All the above three heap codes generate the following output. 
\begin{minted}[breaklines=true]{bash}
After inserting 1,2,3,4,5,6,7,8,9, the array of the heap is 9 8 6 7 3 2 5 1 4 .
Pop out from the heap, we'll get the maximum number 9, and the array of the heap becomes 8 7 6 4 3 2 5 1 .
\end{minted}

\subsection{The application of heap}
\subsubsection{Merge k Sorted Lists}
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity\footnote{https://leetcode.com/problems/merge-k-sorted-lists/description/}.

\begin{minted}[xleftmargin=20pt]{bash}
Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6
\end{minted}


\inputminted[breaklines=true,frame=leftline, linenos=true]{python}{src/mergeKSortedLists.py}

\section{Dynamic Programming}
\subsection{Ugly Number II (LeetCode 264)}
Write a program to find the n-th ugly number. 
Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. 
Example:
\begin{minted}[breaklines=true, xleftmargin=20pt]{bash}
Input: n = 10
Output: 12
Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.
\end{minted}
Note:  
\begin{enumerate}
\item 1 is typically treated as an ugly number.
\item n does not exceed 1690.
\end{enumerate}

Tag: Dynamic Programming.

We use the tabulation dynamic programming to compute n-th ugly number based on the previous ugly numbers. 
The recursive formula is defined as following.
\begin{equation}
	\begin{aligned}
		F(n)=
		\left\{ \begin{aligned}
		1 &, n=1 & (a)\\
		2 &, n=2 & (b)\\
		3 &, n=3 & (c)\\
		4 &, n=4 & (d)\\
		5 &, n=5 & (e)\\
		min\{2*F(n-3), 3*F(n-3), 5*F(n-3)\} &, n>5 & (f)
		\end{aligned}\right.
	\end{aligned}
\end{equation}

\section{Maths}
\subsection{Prime numbers}
\subsubsection{Ugly Number (LeetCode 263)}
Write a program to check whether a given number is an ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.

Example 1:
\begin{minted}[breaklines=true, xleftmargin=20pt]{bash}
Input: 6
Output: true
Explanation: 6 = 2 * 3
\end{minted}

Example 2:
\begin{minted}[breaklines=true, xleftmargin=20pt]{bash}
Input: 8
Output: true
Explanation: 8 = 2 * 2 * 2
\end{minted}

Example 3:
\begin{minted}[breaklines=true, xleftmargin=20pt]{bash}
Input: 14
Output: false 
Explanation: 14 is not ugly since it includes another prime factor 7.
\end{minted}

Note:
\begin{enumerate}
	\item 1 is typically treated as an ugly number.
	\item Input is within the 32-bit signed integer range: [$-2^{31}$, $2^{31}-1$].
\end{enumerate}

We use the while loop to do the check and the decomposition for a given number. Since the given number is within the range [$-2^{31}$, $2^{31}-1$], so we can do the check and the decomposition by recursion without worrying about the stack overflow (exceeding the maximum recursion depth). 
\inputminted[breaklines=true,frame=leftline, linenos=true]{python}{src/isUgly.py}

The recursion version is as following. 
\inputminted[breaklines=true,frame=leftline, linenos=true]{python}{src/isUgly_recursion.py}

\end{document}
